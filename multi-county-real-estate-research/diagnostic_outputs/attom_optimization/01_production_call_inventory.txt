================================================================================
ATTOM API PRODUCTION USAGE INVENTORY
================================================================================

Analysis Date: 2025-12-22
Analyst: Claude Code
Objective: Document all ATTOM API calls in production to identify optimization opportunities

================================================================================
EXECUTIVE SUMMARY
================================================================================

FINDING: Production uses 4-16 ATTOM API calls per property vs 2 calls in validation

Key Inefficiency Identified:
- get_comparable_sales() with enrich_sqft=True (DEFAULT) makes extra API calls
- For each comparable missing sqft data, an additional get_property_detail() is called
- Worst case: 10 comps * 1 extra call each = 10 additional API calls

Estimated Cost Impact:
- Validation pattern: ~$0.19/property (2 calls)
- Production pattern: ~$0.60-$1.55/property (4-16 calls)
- Overspend factor: 3x-8x per property

================================================================================
PART 1: ATTOM CLIENT METHODS (core/attom_client.py)
================================================================================

METHOD 1: get_property_detail(address)
--------------------------------------
Endpoint: /property/detail
Purpose: Fetch basic property information
Returns: PropertyData (address, bedrooms, bathrooms, sqft, year_built, etc.)
Cost: 1 API call
Used By:
  - property_valuation_orchestrator.py:122
  - loudoun_streamlit_app.py:2594
  - utils/loudoun_streamlit_app.py:943
  - utils/diagnose_valuation.py:26
  - enrich_comparable_with_sqft() (THE PROBLEM!)

METHOD 2: get_valuation(address)
--------------------------------
Endpoint: /attomavm/detail (primary) -> /assessment/detail (fallback)
Purpose: Get AVM value estimate or tax assessment
Returns: AVMResult (value, value_low, value_high, confidence)
Cost: 1-3 API calls (tries AVM first, falls back to assessment)
Used By:
  - property_valuation_orchestrator.py:146

Internal Flow:
  1. Try /attomavm/detail first
  2. If 404 or no value -> try /assessment/detail
  3. If error code != 0 -> try assessment
  4. Returns assessment fallback value

METHOD 3: get_comparable_sales(address, radius_miles, months_back, enrich_sqft=True)
------------------------------------------------------------------------------------
Endpoint: /sale/snapshot
Purpose: Find recent sales near the subject property
Returns: List[ComparableProperty]
Cost: 1 + (0 to N) API calls where N = number of comps missing sqft
Used By:
  - property_valuation_orchestrator.py:156-160

*** THIS IS THE MAIN INEFFICIENCY ***

When enrich_sqft=True (DEFAULT):
  1. Call /sale/snapshot to get comparables
  2. For EACH comparable missing sqft:
     - Call enrich_comparable_with_sqft(comp)
     - Which calls get_property_detail(comp.address)
     - Which calls /property/detail

Code excerpt (lines 498-514):
```python
# Enrich with sqft data if requested
if enrich_sqft:
    print(f"Enriching {len(comparables)} comparables with sqft data...")
    enriched_comparables = []
    for i, comp in enumerate(comparables, 1):
        if comp.sqft and comp.sqft > 0:
            enriched_comparables.append(comp)
        else:
            enriched_comp = self.enrich_comparable_with_sqft(comp)  # <-- EXTRA CALL!
            enriched_comparables.append(enriched_comp)
    return enriched_comparables
```

METHOD 4: _get_assessment_value(address)
----------------------------------------
Endpoint: /assessment/detail
Purpose: Get tax assessment value as AVM fallback
Returns: AVMResult
Cost: 1 API call
Used By: Internal fallback in get_valuation()

METHOD 5: enrich_comparable_with_sqft(comp)
-------------------------------------------
Endpoint: /property/detail (indirect)
Purpose: Add sqft data to a comparable that's missing it
Returns: ComparableProperty (updated)
Cost: 1 API call
Used By: get_comparable_sales() loop (when enrich_sqft=True)

*** THE EXPENSIVE HELPER FUNCTION ***

Code excerpt (lines 525-557):
```python
def enrich_comparable_with_sqft(self, comp: ComparableProperty) -> ComparableProperty:
    """
    Enrich a comparable property with sqft data by looking up property detail.
    """
    try:
        property_data = self.get_property_detail(full_address)  # <-- API CALL!
        if property_data and property_data.sqft:
            comp.sqft = property_data.sqft
            comp.price_per_sqft = comp.sale_price / comp.sqft if comp.sqft > 0 else None
```

================================================================================
PART 2: PRODUCTION USAGE FLOWS
================================================================================

FLOW 1: Property Valuation Orchestrator (core/property_valuation_orchestrator.py)
---------------------------------------------------------------------------------

The main production flow for property valuations:

Line 122: CALL #1 - Property Detail
```python
property_data = self.attom.get_property_detail(address)
```

Line 137: (Not ATTOM - uses local sales data)
```python
sales_history = sales_data.get_sales_history(property_data.apn)
```

Line 146: CALL #2 - Valuation (1-3 calls)
```python
avm_result = self.attom.get_valuation(address)
```

Line 156-160: CALLS #3-16 - Comparable Sales + Enrichment
```python
comps = self.attom.get_comparable_sales(
    address=address,
    radius_miles=1.0,
    max_results=10
)
```

PRODUCTION CALL BREAKDOWN:
--------------------------
Minimum Calls: 4 (property detail + AVM + comps + 1 enrichment)
Maximum Calls: 16 (property detail + 3 AVM attempts + comps + 10 enrichments)
Typical Calls: ~8-10 (property detail + 1 AVM + comps + 5 enrichments)


FLOW 2: Streamlit Direct Lookup (loudoun_streamlit_app.py:2594)
---------------------------------------------------------------

Line 2594:
```python
property_data = ATTOM_CLIENT.get_property_detail(address)
```

CALLS: 1 per lookup
Note: This is a simple lookup, not full valuation


FLOW 3: Diagnostic Scripts (utils/diagnose_valuation.py)
---------------------------------------------------------

Line 26:
```python
subject = attom.get_property_detail(address)
```

Line 42:
```python
comparables = attom.get_comparable_sales(address, radius_miles=0.5, months_back=6, enrich_sqft=True)
```

CALLS: 2-12 (property detail + comps with enrichment)


================================================================================
PART 3: VALIDATION SCRIPT PATTERN (compare_rentcast_vs_attom.py)
================================================================================

The validation script uses an EFFICIENT 2-call pattern:

Line 210: CALL #1 - Property Detail
```python
result = self.attom.get_property_detail(address)
```

Line 230: CALL #2 - Direct AVM
```python
result = self.attom.get_avm(address)
```

VALIDATION CALLS: 2 per property
NO comparable sales lookup
NO sqft enrichment

This is why validation cost ~$0.19/property while production costs much more.

================================================================================
PART 4: CALL COUNT COMPARISON
================================================================================

                          | Validation | Production | Difference
--------------------------|------------|------------|------------
Property Detail           |     1      |     1      |     0
AVM/Valuation             |     1      |    1-3     |    0-2
Comparable Sales Query    |     0      |     1      |     1
Comparable Enrichment     |     0      |   0-10     |   0-10
--------------------------|------------|------------|------------
TOTAL                     |     2      |   3-15     |   1-13
COST @ $0.095/call        |   $0.19    | $0.29-1.43 | $0.10-1.24

================================================================================
PART 5: FILES WITH ATTOM DEPENDENCIES
================================================================================

PRODUCTION FILES:
- core/attom_client.py (608 lines) - Primary ATTOM interface
- core/property_valuation_orchestrator.py (571 lines) - Main production flow
- loudoun_streamlit_app.py (line 2594) - Direct lookups
- utils/loudoun_streamlit_app.py (line 943) - Direct lookups

DIAGNOSTIC FILES:
- scripts/compare_rentcast_vs_attom.py - Validation comparison
- utils/diagnose_valuation.py - Property diagnosis
- utils/diagnose_attom_raw.py - Raw API testing

ANALYSIS/EXAMPLE FILES:
- diagnostic_outputs/api_analysis/02_replacement_examples.py - Future patterns

================================================================================
PART 6: OPTIMIZATION OPPORTUNITIES IDENTIFIED
================================================================================

OPPORTUNITY 1: Disable sqft enrichment by default
-------------------------------------------------
Impact: -0 to -10 calls per property
Change: get_comparable_sales(enrich_sqft=False)
Risk: Lose price-per-sqft analysis for some comps
Savings: Up to $0.95 per property

OPPORTUNITY 2: Batch enrichment with local data
-----------------------------------------------
Impact: -0 to -10 calls per property
Change: Use Loudoun parquet data for sqft instead of API
Risk: Data might be stale (but cheaper)
Savings: Up to $0.95 per property

OPPORTUNITY 3: Cache property details aggressively
--------------------------------------------------
Impact: Variable reduction in repeated lookups
Change: Add caching layer like RentCast client has
Risk: Stale data (mitigate with TTL)
Savings: Variable, depends on usage patterns

OPPORTUNITY 4: Skip AVM fallbacks
---------------------------------
Impact: -0 to -2 calls per property
Change: Accept null if primary AVM fails
Risk: Fewer properties with valuations
Savings: Up to $0.19 per property

OPPORTUNITY 5: Limit comparable enrichment
------------------------------------------
Impact: -0 to -7 calls per property
Change: Only enrich top 3 most relevant comps
Risk: Less complete comp analysis
Savings: Up to $0.67 per property

================================================================================
CONCLUSION
================================================================================

The primary cost driver is the COMPARABLE ENRICHMENT LOOP in get_comparable_sales().

With enrich_sqft=True (default), each property valuation can make up to 16 API calls
when only 3-4 are actually needed for the core valuation.

RECOMMENDED IMMEDIATE ACTION:
- Set enrich_sqft=False when calling get_comparable_sales()
- Use local parquet data for sqft lookup instead
- Expected savings: 60-85% reduction in ATTOM API costs

================================================================================
END OF INVENTORY
================================================================================
